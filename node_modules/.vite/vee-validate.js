import {
  resolveDynamicComponent
} from "./chunk.LQWTB4AP.js";
import {
  defineComponent,
  ref
} from "./chunk.5N2EEUQK.js";
import {
  computed,
  getCurrentInstance,
  h,
  inject,
  isRef,
  nextTick,
  onBeforeUnmount,
  onMounted,
  provide,
  reactive,
  toRef,
  unref,
  warn,
  watch
} from "./chunk.IFUYV77P.js";

// node_modules/vee-validate/dist/vee-validate.esm.js
/**
  * vee-validate v4.2.1
  * (c) 2021 Abdelrahman Awad
  * @license MIT
  */
function isCallable(fn) {
  return typeof fn === "function";
}
var isObject = (obj) => obj !== null && !!obj && typeof obj === "object" && !Array.isArray(obj);
function isIndex(value) {
  return Number(value) >= 0;
}
var RULES = {};
function defineRule(id, validator) {
  guardExtend(id, validator);
  RULES[id] = validator;
}
function resolveRule(id) {
  return RULES[id];
}
function guardExtend(id, validator) {
  if (isCallable(validator)) {
    return;
  }
  throw new Error(`Extension Error: The validator '${id}' must be a function.`);
}
function isLocator(value) {
  return isCallable(value) && !!value.__locatorRef;
}
function isHTMLTag(tag) {
  return ["input", "textarea", "select"].includes(tag);
}
function isFileInputNode(tag, attrs) {
  return isHTMLTag(tag) && attrs.type === "file";
}
function isYupValidator(value) {
  return !!value && isCallable(value.validate);
}
function hasCheckedAttr(type) {
  return type === "checkbox" || type === "radio";
}
function isContainerValue(value) {
  return isObject(value) || Array.isArray(value);
}
function isEmptyContainer(value) {
  if (Array.isArray(value)) {
    return value.length === 0;
  }
  return isObject(value) && Object.keys(value).length === 0;
}
function isNotNestedPath(path) {
  return /^\[.+\]$/i.test(path);
}
function isNativeMultiSelect(el) {
  return el.tagName === "SELECT" && el.multiple;
}
function isNativeMultiSelectNode(tag, attrs) {
  const hasTruthyBindingValue = ![false, null, void 0, 0].includes(attrs.multiple) && !Number.isNaN(attrs.multiple);
  return tag === "select" && "multiple" in attrs && hasTruthyBindingValue;
}
function shouldHaveValueBinding(tag, attrs) {
  return isNativeMultiSelectNode(tag, attrs) || isFileInputNode(tag, attrs);
}
function cleanupNonNestedPath(path) {
  if (isNotNestedPath(path)) {
    return path.replace(/\[|\]/gi, "");
  }
  return path;
}
function getFromPath(object, path) {
  if (!object) {
    return void 0;
  }
  if (isNotNestedPath(path)) {
    return object[cleanupNonNestedPath(path)];
  }
  const resolvedValue = path.split(/\.|\[(\d+)\]/).filter(Boolean).reduce((acc, propKey) => {
    if (isContainerValue(acc) && propKey in acc) {
      return acc[propKey];
    }
    return void 0;
  }, object);
  return resolvedValue;
}
function setInPath(object, path, value) {
  if (isNotNestedPath(path)) {
    object[cleanupNonNestedPath(path)] = value;
    return;
  }
  const keys = path.split(/\.|\[(\d+)\]/).filter(Boolean);
  let acc = object;
  for (let i = 0; i < keys.length; i++) {
    if (i === keys.length - 1) {
      acc[keys[i]] = value;
      return;
    }
    if (!(keys[i] in acc)) {
      acc[keys[i]] = isIndex(keys[i + 1]) ? [] : {};
    }
    acc = acc[keys[i]];
  }
}
function unset(object, key) {
  if (Array.isArray(object) && isIndex(key)) {
    object.splice(Number(key), 1);
    return;
  }
  if (isObject(object)) {
    delete object[key];
  }
}
function unsetPath(object, path) {
  if (isNotNestedPath(path)) {
    delete object[cleanupNonNestedPath(path)];
    return;
  }
  const keys = path.split(/\.|\[(\d+)\]/).filter(Boolean);
  let acc = object;
  for (let i = 0; i < keys.length; i++) {
    if (i === keys.length - 1) {
      unset(acc, keys[i]);
      break;
    }
    if (!(keys[i] in acc)) {
      break;
    }
    acc = acc[keys[i]];
  }
  const pathValues = keys.map((_, idx) => {
    return getFromPath(object, keys.slice(0, idx).join("."));
  });
  for (let i = pathValues.length - 1; i >= 0; i--) {
    if (!isEmptyContainer(pathValues[i])) {
      continue;
    }
    if (i === 0) {
      unset(object, keys[0]);
      continue;
    }
    unset(pathValues[i - 1], keys[i - 1]);
  }
}
function keysOf(record) {
  return Object.keys(record);
}
function injectWithSelf(symbol, def = void 0) {
  const vm = getCurrentInstance();
  return inject(symbol, (vm === null || vm === void 0 ? void 0 : vm.provides[symbol]) || def);
}
function warn2(message) {
  warn(`[vee-validate]: ${message}`);
}
function normalizeField(field) {
  if (Array.isArray(field)) {
    return field[0];
  }
  return field;
}
function resolveNextCheckboxValue(currentValue, checkedValue, uncheckedValue) {
  if (Array.isArray(currentValue)) {
    const newVal = [...currentValue];
    const idx = newVal.indexOf(checkedValue);
    idx >= 0 ? newVal.splice(idx, 1) : newVal.push(checkedValue);
    return newVal;
  }
  return currentValue === checkedValue ? uncheckedValue : checkedValue;
}
var normalizeChildren = (context, slotProps) => {
  if (!context.slots.default) {
    return context.slots.default;
  }
  return context.slots.default(slotProps);
};
function getBoundValue(el) {
  if (hasValueBinding(el)) {
    return el._value;
  }
  return void 0;
}
function hasValueBinding(el) {
  return "_value" in el;
}
var isEvent = (evt) => {
  if (!evt) {
    return false;
  }
  if (typeof Event !== "undefined" && isCallable(Event) && evt instanceof Event) {
    return true;
  }
  if (evt && evt.srcElement) {
    return true;
  }
  return false;
};
function normalizeEventValue(value) {
  if (!isEvent(value)) {
    return value;
  }
  const input = value.target;
  if (hasCheckedAttr(input.type) && hasValueBinding(input)) {
    return getBoundValue(input);
  }
  if (input.type === "file" && input.files) {
    return Array.from(input.files);
  }
  if (isNativeMultiSelect(input)) {
    return Array.from(input.options).filter((opt) => opt.selected && !opt.disabled).map(getBoundValue);
  }
  return input.value;
}
function normalizeRules(rules) {
  const acc = {};
  Object.defineProperty(acc, "_$$isNormalized", {
    value: true,
    writable: false,
    enumerable: false,
    configurable: false
  });
  if (!rules) {
    return acc;
  }
  if (isObject(rules) && rules._$$isNormalized) {
    return rules;
  }
  if (isObject(rules)) {
    return Object.keys(rules).reduce((prev, curr) => {
      const params = normalizeParams(rules[curr]);
      if (rules[curr] !== false) {
        prev[curr] = buildParams(params);
      }
      return prev;
    }, acc);
  }
  if (typeof rules !== "string") {
    return acc;
  }
  return rules.split("|").reduce((prev, rule) => {
    const parsedRule = parseRule(rule);
    if (!parsedRule.name) {
      return prev;
    }
    prev[parsedRule.name] = buildParams(parsedRule.params);
    return prev;
  }, acc);
}
function normalizeParams(params) {
  if (params === true) {
    return [];
  }
  if (Array.isArray(params)) {
    return params;
  }
  if (isObject(params)) {
    return params;
  }
  return [params];
}
function buildParams(provided) {
  const mapValueToLocator = (value) => {
    if (typeof value === "string" && value[0] === "@") {
      return createLocator(value.slice(1));
    }
    return value;
  };
  if (Array.isArray(provided)) {
    return provided.map(mapValueToLocator);
  }
  if (provided instanceof RegExp) {
    return [provided];
  }
  return Object.keys(provided).reduce((prev, key) => {
    prev[key] = mapValueToLocator(provided[key]);
    return prev;
  }, {});
}
var parseRule = (rule) => {
  let params = [];
  const name = rule.split(":")[0];
  if (rule.includes(":")) {
    params = rule.split(":").slice(1).join(":").split(",");
  }
  return {name, params};
};
function createLocator(value) {
  const locator = (crossTable) => {
    const val = getFromPath(crossTable, value) || crossTable[value];
    return val;
  };
  locator.__locatorRef = value;
  return locator;
}
function extractLocators(params) {
  if (Array.isArray(params)) {
    return params.filter(isLocator);
  }
  return keysOf(params).filter((key) => isLocator(params[key])).map((key) => params[key]);
}
var DEFAULT_CONFIG = {
  generateMessage: ({field}) => `${field} is not valid.`,
  bails: true,
  validateOnBlur: true,
  validateOnChange: true,
  validateOnInput: false,
  validateOnModelUpdate: true
};
var currentConfig = Object.assign({}, DEFAULT_CONFIG);
var getConfig = () => currentConfig;
var setConfig = (newConf) => {
  currentConfig = Object.assign(Object.assign({}, currentConfig), newConf);
};
var configure = setConfig;
async function validate(value, rules, options = {}) {
  const shouldBail = options === null || options === void 0 ? void 0 : options.bails;
  const field = {
    name: (options === null || options === void 0 ? void 0 : options.name) || "{field}",
    rules,
    bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,
    formData: (options === null || options === void 0 ? void 0 : options.values) || {}
  };
  const result = await _validate(field, value);
  const errors = result.errors;
  return {
    errors,
    valid: !errors.length
  };
}
async function _validate(field, value) {
  if (isYupValidator(field.rules)) {
    return validateFieldWithYup(value, field.rules, {bails: field.bails});
  }
  if (isCallable(field.rules)) {
    const ctx = {
      field: field.name,
      form: field.formData,
      value
    };
    const result = await field.rules(value, ctx);
    const isValid = typeof result !== "string" && result;
    const message = typeof result === "string" ? result : _generateFieldError(ctx);
    return {
      errors: !isValid ? [message] : []
    };
  }
  const normalizedContext = Object.assign(Object.assign({}, field), {rules: normalizeRules(field.rules)});
  const errors = [];
  const rulesKeys = Object.keys(normalizedContext.rules);
  const length = rulesKeys.length;
  for (let i = 0; i < length; i++) {
    const rule = rulesKeys[i];
    const result = await _test(normalizedContext, value, {
      name: rule,
      params: normalizedContext.rules[rule]
    });
    if (result.error) {
      errors.push(result.error);
      if (field.bails) {
        return {
          errors
        };
      }
    }
  }
  return {
    errors
  };
}
async function validateFieldWithYup(value, validator, opts) {
  var _a;
  const errors = await validator.validate(value, {
    abortEarly: (_a = opts.bails) !== null && _a !== void 0 ? _a : true
  }).then(() => []).catch((err) => {
    if (err.name === "ValidationError") {
      return err.errors;
    }
    throw err;
  });
  return {
    errors
  };
}
async function _test(field, value, rule) {
  const validator = resolveRule(rule.name);
  if (!validator) {
    throw new Error(`No such validator '${rule.name}' exists.`);
  }
  const params = fillTargetValues(rule.params, field.formData);
  const ctx = {
    field: field.name,
    value,
    form: field.formData,
    rule: Object.assign(Object.assign({}, rule), {params})
  };
  const result = await validator(value, params, ctx);
  if (typeof result === "string") {
    return {
      error: result
    };
  }
  return {
    error: result ? void 0 : _generateFieldError(ctx)
  };
}
function _generateFieldError(fieldCtx) {
  const message = getConfig().generateMessage;
  if (!message) {
    return "Field is invalid";
  }
  return message(fieldCtx);
}
function fillTargetValues(params, crossTable) {
  const normalize = (value) => {
    if (isLocator(value)) {
      return value(crossTable);
    }
    return value;
  };
  if (Array.isArray(params)) {
    return params.map(normalize);
  }
  return Object.keys(params).reduce((acc, param) => {
    acc[param] = normalize(params[param]);
    return acc;
  }, {});
}
var es6 = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a instanceof Map && b instanceof Map) {
      if (a.size !== b.size)
        return false;
      for (i of a.entries())
        if (!b.has(i[0]))
          return false;
      for (i of a.entries())
        if (!equal(i[1], b.get(i[0])))
          return false;
      return true;
    }
    if (a instanceof Set && b instanceof Set) {
      if (a.size !== b.size)
        return false;
      for (i of a.entries())
        if (!b.has(i[0]))
          return false;
      return true;
    }
    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (a[i] !== b[i])
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var FormContextSymbol = Symbol("vee-validate-form");
var FormErrorsSymbol = Symbol("vee-validate-form-errors");
var FormInitialValuesSymbol = Symbol("vee-validate-form-initial-values");
var FieldContextSymbol = Symbol("vee-validate-field-instance");
var ID_COUNTER = 0;
function useField(name, rules, opts) {
  const fid = ID_COUNTER >= Number.MAX_SAFE_INTEGER ? 0 : ++ID_COUNTER;
  const {initialValue, validateOnMount, bails, type, valueProp, label, validateOnValueUpdate, uncheckedValue} = normalizeOptions(unref(name), opts);
  const form = injectWithSelf(FormContextSymbol);
  const {meta, errors, errorMessage, handleBlur, handleInput, resetValidationState, setValidationState, value, checked} = useValidationState({
    name,
    initValue: initialValue,
    form,
    type,
    valueProp
  });
  const normalizedRules = computed(() => {
    let rulesValue = unref(rules);
    const schema = form === null || form === void 0 ? void 0 : form.schema;
    if (schema && !isYupValidator(schema)) {
      rulesValue = extractRuleFromSchema(schema, unref(name)) || rulesValue;
    }
    if (isYupValidator(rulesValue) || isCallable(rulesValue)) {
      return rulesValue;
    }
    return normalizeRules(rulesValue);
  });
  async function validateWithStateMutation() {
    var _a;
    meta.pending = true;
    let result;
    if (!form || !form.validateSchema) {
      result = await validate(value.value, normalizedRules.value, {
        name: unref(label) || unref(name),
        values: (_a = form === null || form === void 0 ? void 0 : form.values) !== null && _a !== void 0 ? _a : {},
        bails
      });
    } else {
      result = (await form.validateSchema())[unref(name)];
    }
    meta.pending = false;
    return setValidationState(result);
  }
  async function validateValidStateOnly() {
    var _a;
    let result;
    if (!form || !form.validateSchema) {
      result = await validate(value.value, normalizedRules.value, {
        name: unref(label) || unref(name),
        values: (_a = form === null || form === void 0 ? void 0 : form.values) !== null && _a !== void 0 ? _a : {},
        bails
      });
    } else {
      result = (await form.validateSchema(false))[unref(name)];
    }
    meta.valid = result.valid;
  }
  const handleChange = (e) => {
    var _a, _b;
    if (checked && checked.value === ((_b = (_a = e) === null || _a === void 0 ? void 0 : _a.target) === null || _b === void 0 ? void 0 : _b.checked)) {
      return;
    }
    let newValue = normalizeEventValue(e);
    if (checked && type === "checkbox" && !form) {
      newValue = resolveNextCheckboxValue(value.value, unref(valueProp), unref(uncheckedValue));
    }
    value.value = newValue;
    if (!validateOnValueUpdate) {
      return validateWithStateMutation();
    }
  };
  onMounted(() => {
    if (validateOnMount) {
      return validateWithStateMutation();
    }
    if (!form || !form.validateSchema) {
      validateValidStateOnly();
    }
  });
  function setTouched(isTouched) {
    meta.touched = isTouched;
  }
  let unwatchValue;
  function watchValue() {
    unwatchValue = watch(value, validateOnValueUpdate ? validateWithStateMutation : validateValidStateOnly, {
      deep: true
    });
  }
  watchValue();
  function resetField(state) {
    unwatchValue === null || unwatchValue === void 0 ? void 0 : unwatchValue();
    resetValidationState(state);
    watchValue();
  }
  const field = {
    idx: -1,
    fid,
    name,
    value,
    meta,
    errors,
    errorMessage,
    type,
    valueProp,
    uncheckedValue,
    checked,
    resetField,
    handleReset: () => resetField(),
    validate: validateWithStateMutation,
    handleChange,
    handleBlur,
    handleInput,
    setValidationState,
    setTouched
  };
  provide(FieldContextSymbol, field);
  if (isRef(rules) && typeof unref(rules) !== "function") {
    watch(rules, (value2, oldValue) => {
      if (es6(value2, oldValue)) {
        return;
      }
      return validateWithStateMutation();
    }, {
      deep: true
    });
  }
  if (!form) {
    return field;
  }
  form.register(field);
  onBeforeUnmount(() => {
    form.unregister(field);
  });
  const dependencies = computed(() => {
    const rulesVal = normalizedRules.value;
    if (!rulesVal || isCallable(rulesVal) || isYupValidator(rulesVal)) {
      return {};
    }
    return Object.keys(rulesVal).reduce((acc, rule) => {
      const deps = extractLocators(rulesVal[rule]).map((dep) => dep.__locatorRef).reduce((depAcc, depName) => {
        const depValue = getFromPath(form.values, depName) || form.values[depName];
        if (depValue !== void 0) {
          depAcc[depName] = depValue;
        }
        return depAcc;
      }, {});
      Object.assign(acc, deps);
      return acc;
    }, {});
  });
  watch(dependencies, (deps, oldDeps) => {
    if (!Object.keys(deps).length) {
      return;
    }
    const shouldValidate = !es6(deps, oldDeps);
    if (shouldValidate) {
      meta.dirty ? validateWithStateMutation() : validateValidStateOnly();
    }
  });
  return field;
}
function normalizeOptions(name, opts) {
  const defaults = () => ({
    initialValue: void 0,
    validateOnMount: false,
    bails: true,
    rules: "",
    label: name,
    validateOnValueUpdate: true
  });
  if (!opts) {
    return defaults();
  }
  return Object.assign(Object.assign({}, defaults()), opts || {});
}
function useValidationState({name, initValue, form, type, valueProp}) {
  const {errors, errorMessage, setErrors} = useErrorsSource(name, form);
  const formInitialValues = injectWithSelf(FormInitialValuesSymbol, void 0);
  const initialValue = computed(() => {
    var _a;
    return (_a = getFromPath(unref(formInitialValues), unref(name))) !== null && _a !== void 0 ? _a : unref(initValue);
  });
  const value = useFieldValue(initialValue, name, form);
  const meta = useMeta(initialValue, value, errors);
  const checked = hasCheckedAttr(type) ? computed(() => {
    if (Array.isArray(value.value)) {
      return value.value.includes(unref(valueProp));
    }
    return unref(valueProp) === value.value;
  }) : void 0;
  const handleBlur = () => {
    meta.touched = true;
  };
  const handleInput = (e) => {
    if (!hasCheckedAttr(type)) {
      value.value = normalizeEventValue(e);
    }
  };
  function setValidationState(result) {
    setErrors(result.errors);
    return result;
  }
  function resetValidationState(state) {
    var _a, _b;
    const fieldPath = unref(name);
    const newValue = state && "value" in state ? state.value : (_a = getFromPath(unref(formInitialValues), fieldPath)) !== null && _a !== void 0 ? _a : initValue;
    if (form) {
      form.setFieldValue(fieldPath, newValue, {force: true});
    } else {
      value.value = newValue;
    }
    setErrors((state === null || state === void 0 ? void 0 : state.errors) || []);
    meta.touched = (_b = state === null || state === void 0 ? void 0 : state.touched) !== null && _b !== void 0 ? _b : false;
    meta.pending = false;
  }
  return {
    meta,
    errors,
    errorMessage,
    setValidationState,
    resetValidationState,
    handleBlur,
    handleInput,
    value,
    checked
  };
}
function useMeta(initialValue, currentValue, errors) {
  const meta = reactive({
    touched: false,
    pending: false,
    valid: true,
    initialValue: computed(() => unref(initialValue)),
    dirty: computed(() => {
      return !es6(currentValue.value, unref(initialValue));
    })
  });
  watch(errors, (value) => {
    meta.valid = !value.length;
  }, {
    immediate: true,
    flush: "sync"
  });
  return meta;
}
function extractRuleFromSchema(schema, fieldName) {
  if (!schema) {
    return void 0;
  }
  return schema[fieldName];
}
function useFieldValue(initialValue, path, form) {
  if (!form) {
    return ref(unref(initialValue));
  }
  form.stageInitialValue(unref(path), unref(initialValue));
  const value = computed({
    get() {
      return getFromPath(form.values, unref(path));
    },
    set(newVal) {
      form.setFieldValue(unref(path), newVal);
    }
  });
  return value;
}
function useErrorsSource(path, form) {
  if (!form) {
    const errors2 = ref([]);
    return {
      errors: computed(() => errors2.value),
      errorMessage: computed(() => errors2.value[0]),
      setErrors: (messages) => {
        errors2.value = messages;
      }
    };
  }
  const errors = computed(() => form.errorBag.value[unref(path)] || []);
  return {
    errors,
    errorMessage: computed(() => errors.value[0]),
    setErrors: (messages) => {
      form.setFieldErrorBag(unref(path), messages);
    }
  };
}
var Field = defineComponent({
  name: "Field",
  inheritAttrs: false,
  props: {
    as: {
      type: [String, Object],
      default: void 0
    },
    name: {
      type: String,
      required: true
    },
    rules: {
      type: [Object, String, Function],
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: false
    },
    validateOnBlur: {
      type: Boolean,
      default: void 0
    },
    validateOnChange: {
      type: Boolean,
      default: void 0
    },
    validateOnInput: {
      type: Boolean,
      default: void 0
    },
    validateOnModelUpdate: {
      type: Boolean,
      default: void 0
    },
    bails: {
      type: Boolean,
      default: () => getConfig().bails
    },
    label: {
      type: String,
      default: void 0
    },
    uncheckedValue: {
      type: null,
      default: void 0
    },
    modelValue: {
      type: null
    }
  },
  emits: ["update:modelValue"],
  setup(props, ctx) {
    const rules = toRef(props, "rules");
    const name = toRef(props, "name");
    const label = toRef(props, "label");
    const uncheckedValue = toRef(props, "uncheckedValue");
    const {errors, value, errorMessage, validate: validateField, handleChange, handleBlur, handleInput, setTouched, resetField, handleReset, meta, checked} = useField(name, rules, {
      validateOnMount: props.validateOnMount,
      bails: props.bails,
      type: ctx.attrs.type,
      initialValue: hasCheckedAttr(ctx.attrs.type) ? props.modelValue : "modelValue" in props ? props.modelValue : ctx.attrs.value,
      valueProp: ctx.attrs.value,
      uncheckedValue,
      label,
      validateOnValueUpdate: false
    });
    const onChangeHandler = "modelValue" in props ? function handleChangeWithModel(e) {
      handleChange(e);
      ctx.emit("update:modelValue", value.value);
    } : handleChange;
    const onInputHandler = "modelValue" in props ? function handleChangeWithModel(e) {
      handleInput(e);
      ctx.emit("update:modelValue", value.value);
    } : handleInput;
    const fieldProps = computed(() => {
      const {validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate} = resolveValidationTriggers(props);
      const baseOnBlur = [handleBlur, ctx.attrs.onBlur, validateOnBlur ? validateField : void 0].filter(Boolean);
      const baseOnInput = [onInputHandler, validateOnInput ? onChangeHandler : void 0, ctx.attrs.onInput].filter(Boolean);
      const baseOnChange = [onInputHandler, validateOnChange ? onChangeHandler : void 0, ctx.attrs.onChange].filter(Boolean);
      const attrs = {
        name: props.name,
        onBlur: baseOnBlur,
        onInput: baseOnInput,
        onChange: baseOnChange
      };
      if (validateOnModelUpdate) {
        attrs["onUpdate:modelValue"] = [onChangeHandler];
      }
      if (hasCheckedAttr(ctx.attrs.type) && checked) {
        attrs.checked = checked.value;
      } else {
        attrs.value = value.value;
      }
      const tag = resolveTag(props, ctx);
      if (shouldHaveValueBinding(tag, ctx.attrs)) {
        delete attrs.value;
      }
      return attrs;
    });
    const slotProps = computed(() => {
      return {
        field: fieldProps.value,
        value: value.value,
        meta,
        errors: errors.value,
        errorMessage: errorMessage.value,
        validate: validateField,
        resetField,
        handleChange: onChangeHandler,
        handleInput: onInputHandler,
        handleReset,
        handleBlur,
        setTouched
      };
    });
    if ("modelValue" in props) {
      const modelValue = toRef(props, "modelValue");
      watch(modelValue, (newModelValue) => {
        if (newModelValue !== value.value) {
          value.value = newModelValue;
          validateField();
        }
      });
    }
    return () => {
      const tag = resolveDynamicComponent(resolveTag(props, ctx));
      const children = normalizeChildren(ctx, slotProps.value);
      if (tag) {
        return h(tag, Object.assign(Object.assign({}, ctx.attrs), fieldProps.value), children);
      }
      return children;
    };
  }
});
function resolveTag(props, ctx) {
  let tag = props.as || "";
  if (!props.as && !ctx.slots.default) {
    tag = "input";
  }
  return tag;
}
function resolveValidationTriggers(props) {
  var _a, _b, _c, _d;
  const {validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate} = getConfig();
  return {
    validateOnInput: (_a = props.validateOnInput) !== null && _a !== void 0 ? _a : validateOnInput,
    validateOnChange: (_b = props.validateOnChange) !== null && _b !== void 0 ? _b : validateOnChange,
    validateOnBlur: (_c = props.validateOnBlur) !== null && _c !== void 0 ? _c : validateOnBlur,
    validateOnModelUpdate: (_d = props.validateOnModelUpdate) !== null && _d !== void 0 ? _d : validateOnModelUpdate
  };
}
function useForm(opts) {
  const fields = ref([]);
  const isSubmitting = ref(false);
  const fieldsById = computed(() => {
    return fields.value.reduce((acc, field) => {
      const fieldPath = unref(field.name);
      if (!acc[fieldPath]) {
        acc[fieldPath] = field;
        field.idx = -1;
        return acc;
      }
      const existingField = acc[fieldPath];
      if (!Array.isArray(existingField)) {
        existingField.idx = 0;
        acc[fieldPath] = [existingField];
      }
      const fieldGroup = acc[fieldPath];
      field.idx = fieldGroup.length;
      fieldGroup.push(field);
      return acc;
    }, {});
  });
  const submitCount = ref(0);
  const formValues = reactive({});
  const valuesByFid = {};
  const {errorBag, setErrorBag, setFieldErrorBag} = useErrorBag(opts === null || opts === void 0 ? void 0 : opts.initialErrors);
  const errors = computed(() => {
    return keysOf(errorBag.value).reduce((acc, key) => {
      const bag = errorBag.value[key];
      if (bag && bag.length) {
        acc[key] = bag[0];
      }
      return acc;
    }, {});
  });
  const {readonlyInitialValues, initialValues, setInitialValues} = useFormInitialValues(fieldsById, formValues, opts === null || opts === void 0 ? void 0 : opts.initialValues);
  const meta = useFormMeta(fields, formValues, readonlyInitialValues);
  function setFieldError(field, message) {
    setFieldErrorBag(field, message);
  }
  function setErrors(fields2) {
    setErrorBag(fields2);
  }
  function setFieldValue(field, value, {force} = {force: false}) {
    var _a;
    const fieldInstance = fieldsById.value[field];
    if (Array.isArray(fieldInstance) && ((_a = fieldInstance[0]) === null || _a === void 0 ? void 0 : _a.type) === "checkbox" && !Array.isArray(value)) {
      const newVal = resolveNextCheckboxValue(getFromPath(formValues, field) || [], value, void 0);
      setInPath(formValues, field, newVal);
      fieldInstance.forEach((fieldItem) => {
        valuesByFid[fieldItem.fid] = newVal;
      });
      return;
    }
    let newValue = value;
    if (!Array.isArray(fieldInstance) && (fieldInstance === null || fieldInstance === void 0 ? void 0 : fieldInstance.type) === "checkbox" && !force) {
      newValue = resolveNextCheckboxValue(getFromPath(formValues, field), value, unref(fieldInstance.uncheckedValue));
    }
    setInPath(formValues, field, newValue);
    if (fieldInstance && Array.isArray(fieldInstance)) {
      fieldInstance.forEach((fieldItem) => {
        valuesByFid[fieldItem.fid] = newValue;
      });
      return;
    }
    if (fieldInstance) {
      valuesByFid[fieldInstance.fid] = newValue;
    }
  }
  function setValues(fields2) {
    keysOf(fields2).forEach((field) => {
      setFieldValue(field, fields2[field]);
    });
  }
  function setFieldTouched(field, isTouched) {
    const fieldInstance = fieldsById.value[field];
    if (!fieldInstance) {
      return;
    }
    if (Array.isArray(fieldInstance)) {
      fieldInstance.forEach((f) => f.setTouched(isTouched));
      return;
    }
    fieldInstance.setTouched(isTouched);
  }
  function setTouched(fields2) {
    keysOf(fields2).forEach((field) => {
      setFieldTouched(field, !!fields2[field]);
    });
  }
  const resetForm = (state) => {
    if (state === null || state === void 0 ? void 0 : state.values) {
      setInitialValues(state.values);
    }
    fields.value.forEach((f) => f.resetField());
    if (state === null || state === void 0 ? void 0 : state.touched) {
      setTouched(state.touched);
    }
    if (state === null || state === void 0 ? void 0 : state.errors) {
      setErrors(state.errors);
    }
    submitCount.value = (state === null || state === void 0 ? void 0 : state.submitCount) || 0;
  };
  function registerField(field) {
    fields.value.push(field);
    if (isRef(field.name)) {
      valuesByFid[field.fid] = field.value.value;
      watch(field.name, (newPath) => {
        setFieldValue(newPath, valuesByFid[field.fid]);
      }, {
        flush: "post"
      });
    }
  }
  function unregisterField(field) {
    var _a, _b;
    const idx = fields.value.indexOf(field);
    if (idx === -1) {
      return;
    }
    fields.value.splice(idx, 1);
    const fid = field.fid;
    nextTick(() => {
      delete valuesByFid[fid];
    });
    const fieldName = unref(field.name);
    if (field.idx === -1) {
      const isSharingName = fields.value.find((f) => unref(f.name) === fieldName);
      if (isSharingName) {
        return;
      }
      unsetPath(formValues, fieldName);
      unsetPath(initialValues.value, fieldName);
      return;
    }
    const valueIdx = (_b = (_a = getFromPath(formValues, fieldName)) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, unref(field.valueProp));
    if (valueIdx === void 0) {
      unsetPath(formValues, fieldName);
      return;
    }
    if (valueIdx === -1) {
      return;
    }
    if (Array.isArray(formValues[fieldName])) {
      unsetPath(formValues, `${fieldName}.${valueIdx}`);
      return;
    }
    unsetPath(formValues, fieldName);
    unsetPath(initialValues.value, fieldName);
  }
  async function validate2() {
    function resultReducer(acc, result) {
      if (!result.errors.length) {
        return acc;
      }
      acc.valid = false;
      acc.errors[result.key] = result.errors[0];
      return acc;
    }
    if (formCtx.validateSchema) {
      return formCtx.validateSchema(true).then((results2) => {
        return keysOf(results2).map((r) => ({key: r, errors: results2[r].errors})).reduce(resultReducer, {errors: {}, valid: true});
      });
    }
    const results = await Promise.all(fields.value.map((f) => {
      return f.validate().then((result) => {
        return {
          key: unref(f.name),
          errors: result.errors
        };
      });
    }));
    return results.reduce(resultReducer, {errors: {}, valid: true});
  }
  async function validateField(field) {
    const fieldInstance = fieldsById.value[field];
    if (!fieldInstance) {
      warn(`field with name ${field} was not found`);
      return Promise.resolve({errors: [], valid: true});
    }
    if (Array.isArray(fieldInstance)) {
      return fieldInstance.map((f) => f.validate())[0];
    }
    return fieldInstance.validate();
  }
  const handleSubmit = (fn) => {
    return function submissionHandler(e) {
      if (e instanceof Event) {
        e.preventDefault();
        e.stopPropagation();
      }
      isSubmitting.value = true;
      submitCount.value++;
      return validate2().then((result) => {
        if (result.valid && typeof fn === "function") {
          return fn(immutableFormValues.value, {
            evt: e,
            setErrors,
            setFieldError,
            setTouched,
            setFieldTouched,
            setValues,
            setFieldValue,
            resetForm
          });
        }
      }).then(() => {
        isSubmitting.value = false;
      }, (err) => {
        isSubmitting.value = false;
        throw err;
      });
    };
  };
  function stageInitialValue(path, value) {
    setInPath(formValues, path, value);
    setInPath(initialValues.value, path, value);
  }
  const formCtx = {
    register: registerField,
    unregister: unregisterField,
    fields: fieldsById,
    values: formValues,
    setFieldErrorBag,
    errorBag,
    schema: opts === null || opts === void 0 ? void 0 : opts.validationSchema,
    submitCount,
    validateSchema: isYupValidator(opts === null || opts === void 0 ? void 0 : opts.validationSchema) ? (shouldMutate = false) => {
      return validateYupSchema(formCtx, shouldMutate);
    } : void 0,
    validate: validate2,
    validateField,
    setFieldValue,
    setValues,
    setErrors,
    setFieldError,
    setFieldTouched,
    setTouched,
    resetForm,
    meta,
    isSubmitting,
    handleSubmit,
    stageInitialValue
  };
  const immutableFormValues = computed(() => {
    return fields.value.reduce((formData, field) => {
      setInPath(formData, unref(field.name), unref(field.value));
      return formData;
    }, {});
  });
  const submitForm = handleSubmit((_, {evt}) => {
    var _a, _b;
    if (evt) {
      (_b = (_a = evt === null || evt === void 0 ? void 0 : evt.target) === null || _a === void 0 ? void 0 : _a.submit) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
  });
  onMounted(() => {
    if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {
      setErrors(opts.initialErrors);
    }
    if (opts === null || opts === void 0 ? void 0 : opts.initialTouched) {
      setTouched(opts.initialTouched);
    }
    if (opts === null || opts === void 0 ? void 0 : opts.validateOnMount) {
      validate2();
      return;
    }
    if (formCtx.validateSchema) {
      formCtx.validateSchema(false);
    }
  });
  provide(FormContextSymbol, formCtx);
  provide(FormErrorsSymbol, errors);
  return {
    errors,
    meta,
    values: formValues,
    isSubmitting,
    submitCount,
    validate: validate2,
    validateField,
    handleReset: () => resetForm(),
    resetForm,
    handleSubmit,
    submitForm,
    setFieldError,
    setErrors,
    setFieldValue,
    setValues,
    setFieldTouched,
    setTouched
  };
}
function useFormMeta(fields, currentValues, initialValues) {
  const MERGE_STRATEGIES = {
    touched: "some",
    pending: "some",
    valid: "every"
  };
  const isDirty = computed(() => {
    return !es6(currentValues, unref(initialValues));
  });
  return computed(() => {
    const flags = keysOf(MERGE_STRATEGIES).reduce((acc, flag) => {
      const mergeMethod = MERGE_STRATEGIES[flag];
      acc[flag] = fields.value[mergeMethod]((field) => field.meta[flag]);
      return acc;
    }, {});
    return Object.assign(Object.assign({initialValues: unref(initialValues)}, flags), {dirty: isDirty.value});
  });
}
async function validateYupSchema(form, shouldMutate = false) {
  const errors = await form.schema.validate(form.values, {abortEarly: false}).then(() => []).catch((err) => {
    if (err.name !== "ValidationError") {
      throw err;
    }
    return err.inner || [];
  });
  const fields = form.fields.value;
  const errorsByPath = errors.reduce((acc, err) => {
    acc[err.path] = err;
    return acc;
  }, {});
  const aggregatedResult = keysOf(fields).reduce((result, fieldId) => {
    const field = fields[fieldId];
    const messages = (errorsByPath[fieldId] || {errors: []}).errors;
    const fieldResult = {
      errors: messages,
      valid: !messages.length
    };
    result[fieldId] = fieldResult;
    const isTouched = Array.isArray(field) ? field.some((f) => f.meta.touched) : field.meta.touched;
    if (!shouldMutate && !isTouched) {
      if (Array.isArray(field)) {
        field.forEach((f) => f.meta.valid = fieldResult.valid);
      } else {
        field.meta.valid = fieldResult.valid;
      }
      return result;
    }
    if (Array.isArray(field)) {
      field[0].setValidationState(fieldResult);
      return result;
    }
    field.setValidationState(fieldResult);
    return result;
  }, {});
  return aggregatedResult;
}
function useFormInitialValues(fields, formValues, providedValues) {
  const initialValues = ref(unref(providedValues) || {});
  const computedInitials = computed(() => {
    return initialValues.value;
  });
  function setInitialValues(values, updateFields = false) {
    initialValues.value = Object.assign(Object.assign({}, initialValues.value), values);
    if (!updateFields) {
      return;
    }
    const isSafeToUpdate = (f) => f.meta.touched;
    keysOf(fields.value).forEach((fieldPath) => {
      const field = fields.value[fieldPath];
      const touchedByUser = Array.isArray(field) ? field.some(isSafeToUpdate) : isSafeToUpdate(field);
      if (touchedByUser) {
        return;
      }
      const newValue = getFromPath(initialValues.value, fieldPath);
      setInPath(formValues, fieldPath, newValue);
    });
  }
  if (isRef(providedValues)) {
    watch(providedValues, (value) => {
      setInitialValues(value, true);
    }, {
      deep: true
    });
  }
  provide(FormInitialValuesSymbol, computedInitials);
  return {
    readonlyInitialValues: computedInitials,
    initialValues,
    setInitialValues
  };
}
function useErrorBag(initialErrors) {
  const errorBag = ref({});
  function setFieldErrorBag(field, message) {
    errorBag.value[field] = Array.isArray(message) ? message : message ? [message] : [];
  }
  function setErrorBag(fields) {
    keysOf(fields).forEach((field) => {
      setFieldErrorBag(field, fields[field]);
    });
  }
  if (initialErrors) {
    setErrorBag(initialErrors);
  }
  return {
    errorBag,
    setErrorBag,
    setFieldErrorBag
  };
}
var Form = defineComponent({
  name: "Form",
  inheritAttrs: false,
  props: {
    as: {
      type: String,
      default: "form"
    },
    validationSchema: {
      type: Object,
      default: void 0
    },
    initialValues: {
      type: Object,
      default: void 0
    },
    initialErrors: {
      type: Object,
      default: void 0
    },
    initialTouched: {
      type: Object,
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: false
    },
    onSubmit: {
      type: Function,
      default: void 0
    }
  },
  setup(props, ctx) {
    const initialValues = toRef(props, "initialValues");
    const {errors, values, meta, isSubmitting, submitCount, validate: validate2, validateField, handleReset, resetForm, handleSubmit, submitForm, setErrors, setFieldError, setFieldValue, setValues, setFieldTouched, setTouched} = useForm({
      validationSchema: props.validationSchema,
      initialValues,
      initialErrors: props.initialErrors,
      initialTouched: props.initialTouched,
      validateOnMount: props.validateOnMount
    });
    const onSubmit = props.onSubmit ? handleSubmit(props.onSubmit) : submitForm;
    function handleFormReset(e) {
      if (isEvent(e)) {
        e.preventDefault();
      }
      handleReset();
      if (typeof ctx.attrs.onReset === "function") {
        ctx.attrs.onReset();
      }
    }
    function handleScopedSlotSubmit(evt, onSubmit2) {
      const onSuccess = typeof evt === "function" && !onSubmit2 ? evt : onSubmit2;
      return handleSubmit(onSuccess)(evt);
    }
    const slotProps = computed(() => {
      return {
        meta: meta.value,
        errors: errors.value,
        values,
        isSubmitting: isSubmitting.value,
        submitCount: submitCount.value,
        validate: validate2,
        validateField,
        handleSubmit: handleScopedSlotSubmit,
        handleReset,
        submitForm,
        setErrors,
        setFieldError,
        setFieldValue,
        setValues,
        setFieldTouched,
        setTouched,
        resetForm
      };
    });
    return function renderForm() {
      if (!("setErrors" in this)) {
        this.setFieldError = setFieldError;
        this.setErrors = setErrors;
        this.setFieldValue = setFieldValue;
        this.setValues = setValues;
        this.setFieldTouched = setFieldTouched;
        this.setTouched = setTouched;
        this.resetForm = resetForm;
        this.validate = validate2;
        this.validateField = validateField;
      }
      const children = normalizeChildren(ctx, slotProps.value);
      if (!props.as) {
        return children;
      }
      const formAttrs = props.as === "form" ? {
        novalidate: true
      } : {};
      return h(props.as === "form" ? props.as : resolveDynamicComponent(props.as), Object.assign(Object.assign(Object.assign({}, formAttrs), ctx.attrs), {onSubmit, onReset: handleFormReset}), children);
    };
  }
});
var ErrorMessage = defineComponent({
  props: {
    as: {
      type: String,
      default: void 0
    },
    name: {
      type: String,
      required: true
    }
  },
  setup(props, ctx) {
    const errors = inject(FormErrorsSymbol, void 0);
    const message = computed(() => {
      return errors === null || errors === void 0 ? void 0 : errors.value[props.name];
    });
    return () => {
      if (!message.value) {
        return void 0;
      }
      const children = normalizeChildren(ctx, {
        message: message.value
      });
      const tag = props.as ? resolveDynamicComponent(props.as) : props.as;
      const attrs = Object.assign({role: "alert"}, ctx.attrs);
      if (!tag && (children === null || children === void 0 ? void 0 : children.length)) {
        return children;
      }
      if (!(children === null || children === void 0 ? void 0 : children.length)) {
        return h(tag || "span", attrs, message.value);
      }
      return h(tag, attrs, children);
    };
  }
});
function useResetForm() {
  const form = injectWithSelf(FormContextSymbol);
  if (!form) {
    warn2("No vee-validate <Form /> or `useForm` was detected in the component tree");
  }
  return function resetForm(state) {
    if (!form) {
      return;
    }
    return form.resetForm(state);
  };
}
function useIsFieldDirty(path) {
  const form = injectWithSelf(FormContextSymbol);
  let field = path ? void 0 : inject(FieldContextSymbol);
  return computed(() => {
    if (path) {
      field = normalizeField(form === null || form === void 0 ? void 0 : form.fields.value[unref(path)]);
    }
    if (!field) {
      warn2(`field with name ${unref(path)} was not found`);
      return false;
    }
    return field.meta.dirty;
  });
}
function useIsFieldTouched(path) {
  const form = injectWithSelf(FormContextSymbol);
  let field = path ? void 0 : inject(FieldContextSymbol);
  return computed(() => {
    if (path) {
      field = normalizeField(form === null || form === void 0 ? void 0 : form.fields.value[unref(path)]);
    }
    if (!field) {
      warn2(`field with name ${unref(path)} was not found`);
      return false;
    }
    return field.meta.touched;
  });
}
function useIsFieldValid(path) {
  const form = injectWithSelf(FormContextSymbol);
  let field = path ? void 0 : inject(FieldContextSymbol);
  return computed(() => {
    if (path) {
      field = normalizeField(form === null || form === void 0 ? void 0 : form.fields.value[unref(path)]);
    }
    if (!field) {
      warn2(`field with name ${unref(path)} was not found`);
      return false;
    }
    return field.meta.valid;
  });
}
function useIsSubmitting() {
  const form = injectWithSelf(FormContextSymbol);
  if (!form) {
    warn2("No vee-validate <Form /> or `useForm` was detected in the component tree");
  }
  return computed(() => {
    var _a;
    return (_a = form === null || form === void 0 ? void 0 : form.isSubmitting.value) !== null && _a !== void 0 ? _a : false;
  });
}
function useValidateField(path) {
  const form = injectWithSelf(FormContextSymbol);
  let field = path ? void 0 : inject(FieldContextSymbol);
  return function validateField() {
    if (path) {
      field = normalizeField(form === null || form === void 0 ? void 0 : form.fields.value[unref(path)]);
    }
    if (!field) {
      warn2(`field with name ${unref(path)} was not found`);
      return Promise.resolve({
        errors: [],
        valid: true
      });
    }
    return field.validate();
  };
}
function useIsFormDirty() {
  const form = injectWithSelf(FormContextSymbol);
  if (!form) {
    warn2("No vee-validate <Form /> or `useForm` was detected in the component tree");
  }
  return computed(() => {
    var _a;
    return (_a = form === null || form === void 0 ? void 0 : form.meta.value.dirty) !== null && _a !== void 0 ? _a : false;
  });
}
function useIsFormTouched() {
  const form = injectWithSelf(FormContextSymbol);
  if (!form) {
    warn2("No vee-validate <Form /> or `useForm` was detected in the component tree");
  }
  return computed(() => {
    var _a;
    return (_a = form === null || form === void 0 ? void 0 : form.meta.value.touched) !== null && _a !== void 0 ? _a : false;
  });
}
function useIsFormValid() {
  const form = injectWithSelf(FormContextSymbol);
  if (!form) {
    warn2("No vee-validate <Form /> or `useForm` was detected in the component tree");
  }
  return computed(() => {
    var _a;
    return (_a = form === null || form === void 0 ? void 0 : form.meta.value.valid) !== null && _a !== void 0 ? _a : false;
  });
}
function useValidateForm() {
  const form = injectWithSelf(FormContextSymbol);
  if (!form) {
    warn2("No vee-validate <Form /> or `useForm` was detected in the component tree");
  }
  return function validateField() {
    if (!form) {
      return Promise.resolve({errors: {}, valid: true});
    }
    return form.validate();
  };
}
function useSubmitCount() {
  const form = injectWithSelf(FormContextSymbol);
  if (!form) {
    warn2("No vee-validate <Form /> or `useForm` was detected in the component tree");
  }
  return computed(() => {
    var _a;
    return (_a = form === null || form === void 0 ? void 0 : form.submitCount.value) !== null && _a !== void 0 ? _a : 0;
  });
}
function useFieldValue$1(path) {
  const form = injectWithSelf(FormContextSymbol);
  const field = path ? void 0 : inject(FieldContextSymbol);
  return computed(() => {
    var _a;
    if (path) {
      return getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(path));
    }
    return (_a = field === null || field === void 0 ? void 0 : field.value) === null || _a === void 0 ? void 0 : _a.value;
  });
}
function useFormValues() {
  const form = injectWithSelf(FormContextSymbol);
  if (!form) {
    warn2("No vee-validate <Form /> or `useForm` was detected in the component tree");
  }
  return computed(() => {
    return (form === null || form === void 0 ? void 0 : form.values) || {};
  });
}
function useFormErrors() {
  const errors = injectWithSelf(FormErrorsSymbol);
  if (!errors) {
    warn2("No vee-validate <Form /> or `useForm` was detected in the component tree");
  }
  return errors || computed(() => ({}));
}
function useFieldError(path) {
  const errors = injectWithSelf(FormErrorsSymbol);
  const field = path ? void 0 : inject(FieldContextSymbol);
  return computed(() => {
    var _a;
    if (path) {
      return (_a = errors === null || errors === void 0 ? void 0 : errors.value) === null || _a === void 0 ? void 0 : _a[unref(path)];
    }
    return field === null || field === void 0 ? void 0 : field.errorMessage.value;
  });
}
function useSubmitForm(cb) {
  const form = injectWithSelf(FormContextSymbol);
  if (!form) {
    warn2("No vee-validate <Form /> or `useForm` was detected in the component tree");
  }
  const onSubmit = form ? form.handleSubmit(cb) : void 0;
  return function submitForm(e) {
    if (!onSubmit) {
      return;
    }
    return onSubmit(e);
  };
}
export {
  ErrorMessage,
  Field,
  Form,
  configure,
  defineRule,
  useField,
  useFieldError,
  useFieldValue$1 as useFieldValue,
  useForm,
  useFormErrors,
  useFormValues,
  useIsFieldDirty,
  useIsFieldTouched,
  useIsFieldValid,
  useIsFormDirty,
  useIsFormTouched,
  useIsFormValid,
  useIsSubmitting,
  useResetForm,
  useSubmitCount,
  useSubmitForm,
  useValidateField,
  useValidateForm,
  validate
};
//# sourceMappingURL=vee-validate.js.map
